import { SlashCommandBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle, EmbedBuilder, AttachmentBuilder, MessageFlags } from 'discord.js';
import googleDriveService from '../services/googleDrive.js';
import { 
    createSuccessEmbed, 
    createErrorEmbed, 
    createInfoEmbed, 
    createLoadingEmbed 
} from '../utils/embeds.js';
import { 
    formatFileSize, 
    formatDate, 
    getFileIcon, 
    getFolderIcon, 
    createBreadcrumb, 
    truncateString,
    getRandomCuteResponse,
    getRandomErrorResponse
} from '../utils/helpers.js';
import { validateFileSize, validateFileName } from '../utils/validation.js';
import { createLogger } from '../utils/logger.js';

const logger = createLogger();

// Constants
const TIMEOUT_DURATION = 300000; // 5 minutes
const MAX_FOLDER_DISPLAY = 5;
const MAX_FILE_DISPLAY = 8;
const TEMP_FILE_CLEANUP_DELAY = 5000;

const EMBED_COLORS = {
    SUCCESS: '#00ff00',
    ERROR: '#ff0000',
    WARNING: '#ffa500',
    INFO: '#4285f4',
    PROCESSING: '#ffff00',
    SHARE: '#00D4AA',
    PREMIUM: '#9945FF'
};

const FILE_CATEGORIES = {
    IMAGES: ['jpg', 'jpeg', 'png', 'gif', 'bmp', 'svg', 'webp'],
    DOCUMENTS: ['pdf', 'doc', 'docx', 'txt', 'rtf', 'odt'],
    ARCHIVES: ['zip', 'rar', '7z', 'tar', 'gz']
};

/**
 * Create not connected embed with cute Vietnamese style
 */
function createNotConnectedEmbed() {
    return new EmbedBuilder()
        .setColor(EMBED_COLORS.WARNING)
        .setTitle('üîó Onii-chan ch∆∞a k·∫øt n·ªëi Google Drive n√®~')
        .setDescription('Em c·∫ßn onii-chan k·∫øt n·ªëi Google Drive tr∆∞·ªõc khi s·ª≠ d·ª•ng t√≠nh nƒÉng n√†y! ü•∫')
        .addFields([
            { 
                name: 'üöÄ C√°ch k·∫øt n·ªëi n√®~', 
                value: 'S·ª≠ d·ª•ng l·ªánh `/gdrive link` ƒë·ªÉ k·∫øt n·ªëi t√†i kho·∫£n Google Drive c·ªßa onii-chan nh√©! ‚ú®',
                inline: false 
            }
        ])
        .setFooter({ text: 'üíñ Hina Bot ‚Ä¢ Em y√™u c·ªßa onii-chan' })
        .setTimestamp();
}

/**
 * Enhanced file icon function with more types
 */
function getEnhancedFileIcon(filename) {
    const extension = filename.split('.').pop().toLowerCase();
    
    const icons = {
        // Images
        jpg: 'üñºÔ∏è', jpeg: 'üñºÔ∏è', png: 'üñºÔ∏è', gif: 'üéûÔ∏è', bmp: 'üñºÔ∏è', svg: 'üé®', webp: 'üñºÔ∏è',
        // Documents  
        pdf: 'üìÑ', doc: 'üìù', docx: 'üìù', txt: 'üìÉ', rtf: 'üìÑ', odt: 'üìÑ',
        // Archives
        zip: 'üì¶', rar: 'üì¶', '7z': 'üì¶', tar: 'üì¶', gz: 'üì¶',
        // Audio
        mp3: 'üéµ', wav: 'üéµ', flac: 'üéµ', aac: 'üéµ',
        // Video
        mp4: 'üé¨', avi: 'üé¨', mkv: 'üé¨', mov: 'üé¨',
        // Code
        js: 'üíª', py: 'üêç', html: 'üåê', css: 'üé®', json: '‚öôÔ∏è'
    };
    
    return icons[extension] || 'üìÑ';
}

export default {
    data: new SlashCommandBuilder()
        .setName('gdrive')
        .setDescription('Google Drive management commands')
        .addSubcommand(subcommand =>
            subcommand
                .setName('link')
                .setDescription('K·∫øt n·ªëi v·ªõi Google Drive c·ªßa b·∫°n')
        )
        .addSubcommand(subcommand =>
            subcommand
                .setName('unlink')
                .setDescription('Ng·∫Øt k·∫øt n·ªëi v·ªõi Google Drive')
        )
        .addSubcommand(subcommand =>
            subcommand
                .setName('status')
                .setDescription('Ki·ªÉm tra tr·∫°ng th√°i k·∫øt n·ªëi Google Drive')
        )
        .addSubcommand(subcommand =>
            subcommand
                .setName('verify')
                .setDescription('X√°c th·ª±c m√£ code t·ª´ Google')
                .addStringOption(option =>
                    option
                        .setName('code')
                        .setDescription('M√£ code t·ª´ Google OAuth')
                        .setRequired(true)
                )
        )
        .addSubcommand(subcommand =>
            subcommand
                .setName('upload')
                .setDescription('Upload file l√™n Google Drive')
                .addAttachmentOption(option =>
                    option
                        .setName('file')
                        .setDescription('File c·∫ßn upload (t·ªëi ƒëa 8MB)')
                        .setRequired(true)
                )
        )
        .addSubcommand(subcommand =>
            subcommand
                .setName('download')
                .setDescription('Download file t·ª´ Google Drive')
                .addStringOption(option =>
                    option
                        .setName('filename')
                        .setDescription('T√™n file c·∫ßn download')
                        .setRequired(true)
                )
        )
        .addSubcommand(subcommand =>
            subcommand
                .setName('list')
                .setDescription('Hi·ªÉn th·ªã danh s√°ch file trong Google Drive')
                .addStringOption(option =>
                    option
                        .setName('folder')
                        .setDescription('T√™n folder (ƒë·ªÉ tr·ªëng ƒë·ªÉ xem root)')
                        .setRequired(false)
                )
        )
        .addSubcommand(subcommand =>
            subcommand
                .setName('share')
                .setDescription('Chia s·∫ª file c√¥ng khai')
                .addStringOption(option =>
                    option
                        .setName('filename')
                        .setDescription('T√™n file c·∫ßn chia s·∫ª')
                        .setRequired(true)
                )
        )
        .addSubcommand(subcommand =>
            subcommand
                .setName('delete')
                .setDescription('X√≥a file kh·ªèi Google Drive')
                .addStringOption(option =>
                    option
                        .setName('filename')
                        .setDescription('T√™n file c·∫ßn x√≥a')
                        .setRequired(true)
                )
        ),

    async execute(interaction) {
        const subcommand = interaction.options.getSubcommand();
        const userId = interaction.user.id;

        try {
            switch (subcommand) {
                case 'link':
                    await handleLink(interaction, userId);
                    break;
                case 'unlink':
                    await handleUnlink(interaction, userId);
                    break;
                case 'status':
                    await handleStatus(interaction, userId);
                    break;
                case 'verify':
                    await handleVerify(interaction, userId);
                    break;
                case 'upload':
                    await handleUpload(interaction, userId);
                    break;
                case 'download':
                    await handleDownload(interaction, userId);
                    break;
                case 'list':
                    await handleList(interaction, userId);
                    break;
                case 'share':
                    await handleShare(interaction, userId);
                    break;
                case 'delete':
                    await handleDelete(interaction, userId);
                    break;
                default:
                    await interaction.reply({
                        embeds: [createErrorEmbed('Unknown Command', 'Kh√¥ng hi·ªÉu l·ªánh n√†y! ü§î')],
                        flags: MessageFlags.Ephemeral
                    });
            }
        } catch (error) {
            const errorEmbed = createErrorEmbed(
                'Command Error',
                `${getRandomErrorResponse()}\nL·ªói: ${error.message}`
            );
            
            logger.error('Error executing command gdrive:', error);
            
            // Check if interaction has been replied to
            if (interaction.replied || interaction.deferred) {
                try {
                    await interaction.followUp({ embeds: [errorEmbed], flags: MessageFlags.Ephemeral });
                } catch (followUpError) {
                    logger.error('Failed to send follow-up error message:', followUpError);
                }
            } else {
                try {
                    await interaction.reply({ embeds: [errorEmbed], flags: MessageFlags.Ephemeral });
                } catch (replyError) {
                    logger.error('Failed to send error reply:', replyError);
                }
            }
        }
    }
};

async function handleLink(interaction, userId) {
    if (googleDriveService.isUserAuthenticated(userId)) {
        const embed = new EmbedBuilder()
            .setColor(EMBED_COLORS.SUCCESS)
            .setTitle('‚úÖ Yay~! Google Drive ƒë√£ k·∫øt n·ªëi r·ªìi!')
            .setDescription('T√†i kho·∫£n Google Drive c·ªßa onii-chan ƒë√£ ƒë∆∞·ª£c k·∫øt n·ªëi th√†nh c√¥ng r·ªìi! üéâ')
            .addFields([
                { 
                    name: 'üéØ T√≠nh nƒÉng c√≥ s·∫µn cho onii-chan~', 
                    value: '‚Ä¢ `/gdrive upload` - Upload file l√™n n√®!\n‚Ä¢ `/gdrive list` - Xem danh s√°ch file\n‚Ä¢ `/gdrive share` - Chia s·∫ª file v·ªõi m·ªçi ng∆∞·ªùi\n‚Ä¢ `/gdrive download` - Download file v·ªÅ m√°y\n‚Ä¢ `/gdrive delete` - X√≥a file kh√¥ng c·∫ßn thi·∫øt',
                    inline: false 
                }
            ])
            .setFooter({ text: 'üíñ Hina Bot ‚Ä¢ Em y√™u c·ªßa onii-chan' })
            .setTimestamp();
        
        return await interaction.reply({ embeds: [embed], flags: MessageFlags.Ephemeral });
    }

    try {
        const authUrl = googleDriveService.getAuthUrl();
        
        const embed = new EmbedBuilder()
            .setColor(EMBED_COLORS.INFO)
            .setTitle('üîó K·∫øt n·ªëi Google Drive v·ªõi em n√®~')
            .setDescription('ƒê·ªÉ s·ª≠ d·ª•ng t√≠nh nƒÉng Google Drive, onii-chan c·∫ßn k·∫øt n·ªëi t√†i kho·∫£n Google tr∆∞·ªõc nh√©! ü•∫')
            .addFields([
                { 
                    name: 'ÔøΩ H∆∞·ªõng d·∫´n cho onii-chan~', 
                    value: '1. Click v√†o n√∫t "üîó K·∫øt n·ªëi Google Drive" b√™n d∆∞·ªõi n√®!\n2. ƒêƒÉng nh·∫≠p v√†o Google account v√† cho ph√©p truy c·∫≠p\n3. **Copy to√†n b·ªô m√£ code** sau khi authorize\n4. S·ª≠ d·ª•ng l·ªánh `/gdrive verify` v√† paste code v√†o nh√©~',
                    inline: false 
                },
                { 
                    name: 'üí° M·∫πo nh·ªè t·ª´ em~', 
                    value: '‚Ä¢ Onii-chan c√≥ th·ªÉ paste to√†n b·ªô URL ho·∫∑c ch·ªâ m√£ code\n‚Ä¢ M√£ ch·ªâ s·ª≠ d·ª•ng ƒë∆∞·ª£c 1 l·∫ßn v√† c√≥ th·ªùi h·∫°n ƒë·∫•y!\n‚Ä¢ N·∫øu c√≥ l·ªói, h√£y l·∫•y link m·ªõi nha! üíï',
                    inline: false 
                }
            ])
            .setFooter({ text: 'üíñ Hina Bot ‚Ä¢ Em y√™u c·ªßa onii-chan' })
            .setTimestamp();
        
        const linkButton = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setLabel('üîó K·∫øt n·ªëi Google Drive')
                    .setStyle(ButtonStyle.Link)
                    .setURL(authUrl),
                new ButtonBuilder()
                    .setCustomId(`gdrive_help_${userId}`)
                    .setLabel('‚ùì H∆∞·ªõng d·∫´n chi ti·∫øt')
                    .setStyle(ButtonStyle.Secondary)
            );
        
        await interaction.reply({ 
            embeds: [embed], 
            components: [linkButton], 
            flags: MessageFlags.Ephemeral 
        });
        
    } catch (error) {
        logger.error(`Link generation failed for user ${userId}:`, error.message);
        
        const errorEmbed = createErrorEmbed(
            'Link Generation Failed',
            `Kh√¥ng th·ªÉ t·∫°o link k·∫øt n·ªëi Google Drive. ${getRandomErrorResponse()}`
        );
        
        // Check if interaction has been replied to
        if (interaction.replied || interaction.deferred) {
            try {
                await interaction.followUp({ embeds: [errorEmbed], flags: MessageFlags.Ephemeral });
            } catch (followUpError) {
                logger.error('Failed to send follow-up in handleLink:', followUpError);
            }
        } else {
            try {
                await interaction.reply({ embeds: [errorEmbed], flags: MessageFlags.Ephemeral });
            } catch (replyError) {
                logger.error('Failed to send reply in handleLink:', replyError);
            }
        }
    }
}

async function handleUnlink(interaction, userId) {
    if (!googleDriveService.isUserAuthenticated(userId)) {
        const notLinkedEmbed = createInfoEmbed(
            'Not Linked',
            `B·∫°n ch∆∞a k·∫øt n·ªëi Google Drive! üòÖ\nD√πng \`/gdrive link\` ƒë·ªÉ k·∫øt n·ªëi nh√©! üíñ`
        );

        return await interaction.reply({ embeds: [notLinkedEmbed], flags: MessageFlags.Ephemeral });
    }

    googleDriveService.unlinkUser(userId);
    
    const unlinkEmbed = createSuccessEmbed(
        'Unlinked Successfully',
        `ƒê√£ ng·∫Øt k·∫øt n·ªëi Google Drive th√†nh c√¥ng! ${getRandomCuteResponse()}\n\nD√πng \`/gdrive link\` ƒë·ªÉ k·∫øt n·ªëi l·∫°i nh√©! üòä`
    );

    await interaction.reply({ embeds: [unlinkEmbed], flags: MessageFlags.Ephemeral });
}

async function handleStatus(interaction, userId) {
    await interaction.deferReply({ flags: MessageFlags.Ephemeral });

    try {
        const status = await googleDriveService.getUserStatus(userId);
        
        if (!status.authenticated) {
            const notAuthEmbed = createInfoEmbed(
                'Not Authenticated',
                `B·∫°n ch∆∞a k·∫øt n·ªëi Google Drive! üòÖ\nD√πng \`/gdrive link\` ƒë·ªÉ k·∫øt n·ªëi nh√©! üíñ`
            );

            return await interaction.editReply({ embeds: [notAuthEmbed] });
        }

        const statusEmbed = createSuccessEmbed(
            'Google Drive Status',
            `**Connected:** ‚úÖ Yes\n**User:** ${status.user?.displayName || 'Unknown'}\n**Email:** ${status.user?.emailAddress || 'Unknown'}\n\n**Storage Usage:**\n**Used:** ${formatFileSize(status.storage?.usage || 0)}\n**Total:** ${formatFileSize(status.storage?.limit || 0)}\n\n${getRandomCuteResponse()}`
        );

        await interaction.editReply({ embeds: [statusEmbed] });
    } catch (error) {
        const errorEmbed = createErrorEmbed(
            'Status Check Failed',
            `Kh√¥ng th·ªÉ ki·ªÉm tra tr·∫°ng th√°i: ${error.message} üòÖ`
        );

        await interaction.editReply({ embeds: [errorEmbed] });
    }
}

async function handleVerify(interaction, userId) {
    if (googleDriveService.isUserAuthenticated(userId)) {
        const embed = new EmbedBuilder()
            .setColor(EMBED_COLORS.INFO)
            .setTitle('‚ÑπÔ∏è Onii-chan ƒë√£ k·∫øt n·ªëi r·ªìi m√†~')
            .setDescription('T√†i kho·∫£n Google Drive c·ªßa onii-chan ƒë√£ ƒë∆∞·ª£c k·∫øt n·ªëi r·ªìi! üéâ')
            .setFooter({ text: 'üíñ Hina Bot ‚Ä¢ Em y√™u c·ªßa onii-chan' })
            .setTimestamp();
        
        return await interaction.reply({ embeds: [embed], flags: MessageFlags.Ephemeral });
    }
    
    const codeInput = interaction.options.getString('code');
    
    // Extract authorization code from URL if a full URL is provided
    let authCode = codeInput;
    
    // Check if input is a full OAuth URL and extract the code
    if (codeInput.includes('code=')) {
        try {
            const url = new URL(codeInput);
            authCode = url.searchParams.get('code');
        } catch (error) {
            // If URL parsing fails, try regex
            const codeMatch = codeInput.match(/code=([^&]+)/);
            authCode = codeMatch ? codeMatch[1] : codeInput;
        }
    }
    
    if (!authCode || authCode.trim() === '') {
        const embed = new EmbedBuilder()
            .setColor(EMBED_COLORS.ERROR)
            .setTitle('‚ùå Thi·∫øu m√£ x√°c minh r·ªìi onii-chan~')
            .setDescription('Onii-chan vui l√≤ng cung c·∫•p m√£ x√°c minh ho·∫∑c URL t·ª´ Google OAuth nh√©! ü•∫')
            .addFields([
                { 
                    name: 'üìù C√°ch s·ª≠ d·ª•ng n√®~', 
                    value: '‚Ä¢ Paste to√†n b·ªô URL: `/gdrive verify https://example.com/oauth/callback?code=ABC123`\n‚Ä¢ Ho·∫∑c ch·ªâ paste m√£: `/gdrive verify ABC123`',
                    inline: false 
                },
                { 
                    name: 'üîó L·∫•y m√£ m·ªõi nha~', 
                    value: 'S·ª≠ d·ª•ng l·ªánh `/gdrive link` ƒë·ªÉ l·∫•y link OAuth m·ªõi nh√©!',
                    inline: false 
                }
            ])
            .setFooter({ text: 'üíñ Hina Bot ‚Ä¢ Em y√™u c·ªßa onii-chan' })
            .setTimestamp();
        
        return await interaction.reply({ embeds: [embed], flags: MessageFlags.Ephemeral });
    }
    
    await interaction.deferReply({ flags: MessageFlags.Ephemeral });

    try {
        const loadingEmbed = createLoadingEmbed(
            'Verifying Code',
            'ƒêang x√°c th·ª±c m√£ code... Ch·ªù ch√∫t nh√©! üîÑ'
        );

        await interaction.editReply({ embeds: [loadingEmbed] });

        await googleDriveService.storeTokens(userId, authCode);
        
        const embed = new EmbedBuilder()
            .setColor(EMBED_COLORS.SUCCESS)
            .setTitle('‚úÖ Kyaa~! K·∫øt n·ªëi th√†nh c√¥ng r·ªìi!')
            .setDescription(`Ch√†o m·ª´ng onii-chan **${interaction.user.username}** ƒë·∫øn v·ªõi Google Drive Manager c·ªßa em! üéâ`)
            .addFields([
                { 
                    name: 'üéØ T√≠nh nƒÉng c√≥ s·∫µn cho onii-chan~', 
                    value: '‚Ä¢ `/gdrive upload` - Upload file l√™n n√®!\n‚Ä¢ `/gdrive list` - Xem danh s√°ch file\n‚Ä¢ `/gdrive share` - Chia s·∫ª file v·ªõi m·ªçi ng∆∞·ªùi\n‚Ä¢ `/gdrive download` - Download file v·ªÅ m√°y\n‚Ä¢ `/gdrive delete` - X√≥a file kh√¥ng c·∫ßn thi·∫øt',
                    inline: false 
                }
            ])
            .setFooter({ text: 'üíñ Hina Bot ‚Ä¢ Em y√™u c·ªßa onii-chan' })
            .setTimestamp();
        
        const actionButtons = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId(`gdrive_list_${userId}`)
                    .setLabel('üìã Xem File')
                    .setStyle(ButtonStyle.Primary),
                new ButtonBuilder()
                    .setCustomId(`gdrive_status_${userId}`)
                    .setLabel('üìä Tr·∫°ng th√°i')
                    .setStyle(ButtonStyle.Secondary)
            );
        
        await interaction.editReply({ 
            embeds: [embed], 
            components: [actionButtons] 
        });
        
    } catch (error) {
        logger.error(`Verify failed for user ${userId}:`, error.message);
        
        const errorEmbed = new EmbedBuilder()
            .setColor(EMBED_COLORS.ERROR)
            .setTitle('‚ùå L·ªói x√°c minh')
            .setDescription('Kh√¥ng th·ªÉ x√°c minh m√£ k·∫øt n·ªëi. Vui l√≤ng th·ª≠ l·∫°i.')
            .addFields([
                { 
                    name: '‚ö†Ô∏è Chi ti·∫øt l·ªói', 
                    value: error.message.includes('invalid_grant') ? 'M√£ x√°c minh ƒë√£ h·∫øt h·∫°n ho·∫∑c kh√¥ng h·ª£p l·ªá' : error.message,
                    inline: false 
                },
                { 
                    name: 'ÔøΩ Gi·∫£i ph√°p', 
                    value: '‚Ä¢ L·∫•y m√£ m·ªõi t·ª´ Google (m√£ ch·ªâ d√πng ƒë∆∞·ª£c 1 l·∫ßn)\n‚Ä¢ ƒê·∫£m b·∫£o paste ƒë√∫ng to√†n b·ªô URL ho·∫∑c m√£\n‚Ä¢ S·ª≠ d·ª•ng l·∫°i l·ªánh `/gdrive link` ƒë·ªÉ l·∫•y link m·ªõi',
                    inline: false 
                }
            ])
            .setFooter({ text: 'üíñ Hina Bot ‚Ä¢ Error Handler' })
            .setTimestamp();
        
        const retryButton = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId(`gdrive_link_${userId}`)
                    .setLabel('üîó L·∫•y link m·ªõi')
                    .setStyle(ButtonStyle.Primary)
            );
        
        await interaction.editReply({ 
            embeds: [errorEmbed], 
            components: [retryButton] 
        });
    }
}

async function handleUpload(interaction, userId) {
    if (!googleDriveService.isUserAuthenticated(userId)) {
        const embed = createNotConnectedEmbed();
        return await interaction.reply({ embeds: [embed], flags: MessageFlags.Ephemeral });
    }

    const attachment = interaction.options.getAttachment('file');
    
    if (!validateFileSize(attachment.size)) {
        const sizeErrorEmbed = new EmbedBuilder()
            .setColor(EMBED_COLORS.ERROR)
            .setTitle('üìè Huhu~ File qu√° l·ªõn r·ªìi!')
            .setDescription(`File c·ªßa onii-chan qu√° l·ªõn! Em ch·ªâ c√≥ th·ªÉ nh·∫≠n file t·ªëi ƒëa 8MB th√¥i! ü•∫`)
            .addFields([
                { 
                    name: 'ÔøΩ Th√¥ng tin file n√®~', 
                    value: `**üìÑ T√™n:** ${attachment.name}\n**üìè K√≠ch th∆∞·ªõc:** ${formatFileSize(attachment.size)}\n**üö´ Gi·ªõi h·∫°n:** 8MB`,
                    inline: false 
                },
                { 
                    name: 'üí° G·ª£i √Ω t·ª´ em~', 
                    value: '‚Ä¢ N√©n file l·∫°i ƒë·ªÉ gi·∫£m dung l∆∞·ª£ng\n‚Ä¢ Chia file th√†nh nhi·ªÅu ph·∫ßn nh·ªè\n‚Ä¢ Upload tr·ª±c ti·∫øp l√™n Google Drive qua web',
                    inline: false 
                }
            ])
            .setFooter({ text: 'üíñ Hina Bot ‚Ä¢ Em xin l·ªói onii-chan...' })
            .setTimestamp();

        return await interaction.reply({ embeds: [sizeErrorEmbed], flags: MessageFlags.Ephemeral });
    }

    if (!validateFileName(attachment.name)) {
        const nameErrorEmbed = new EmbedBuilder()
            .setColor(EMBED_COLORS.ERROR)
            .setTitle('üìù T√™n file kh√¥ng h·ª£p l·ªá n√®~')
            .setDescription(`T√™n file c·ªßa onii-chan c√≥ k√Ω t·ª± ƒë·∫∑c bi·ªát m√† em kh√¥ng th·ªÉ x·ª≠ l√Ω ƒë∆∞·ª£c! üòÖ`)
            .addFields([
                { 
                    name: 'üî§ K√Ω t·ª± ƒë∆∞·ª£c ph√©p~', 
                    value: 'Ch·ªØ c√°i (a-z, A-Z), s·ªë (0-9), d·∫•u g·∫°ch d∆∞·ªõi (_), d·∫•u g·∫°ch ngang (-), v√† d·∫•u ch·∫•m (.)',
                    inline: false 
                }
            ])
            .setFooter({ text: 'üíñ Hina Bot ‚Ä¢ Em y√™u c·ªßa onii-chan' })
            .setTimestamp();

        return await interaction.reply({ embeds: [nameErrorEmbed], flags: MessageFlags.Ephemeral });
    }

    await interaction.deferReply({ flags: MessageFlags.Ephemeral });

    try {
        const loadingEmbed = createLoadingEmbed(
            'Uploading File',
            `ƒêang upload **${attachment.name}**... Onii-chan ch·ªù em ch√∫t nh√©! üì§‚ú®`
        );

        await interaction.editReply({ embeds: [loadingEmbed] });

        // Download file from Discord
        const response = await fetch(attachment.url);
        const fileBuffer = await response.arrayBuffer();

        // Upload to Google Drive
        const uploadedFile = await googleDriveService.uploadFile(
            userId,
            Buffer.from(fileBuffer),
            attachment.name,
            attachment.contentType
        );

        const successEmbed = new EmbedBuilder()
            .setColor(EMBED_COLORS.SUCCESS)
            .setTitle('üéâ Kyaa~! Upload th√†nh c√¥ng r·ªìi!')
            .setDescription(`${getRandomCuteResponse()}\n\nFile **${uploadedFile.name}** ƒë√£ ƒë∆∞·ª£c em upload l√™n Google Drive cho onii-chan r·ªìi! üíñ`)
            .addFields([
                { 
                    name: 'üìÑ Th√¥ng tin file n√®~', 
                    value: `**${getEnhancedFileIcon(uploadedFile.name)} T√™n:** ${uploadedFile.name}\n` +
                          `**üìè K√≠ch th∆∞·ªõc:** ${formatFileSize(uploadedFile.size)}\n` +
                          `**üîñ Lo·∫°i:** ${uploadedFile.mimeType}\n` +
                          `**üìÖ Upload l√∫c:** ${formatDate(uploadedFile.createdTime)}`,
                    inline: false 
                },
                { 
                    name: 'üöÄ H√†nh ƒë·ªông nhanh cho onii-chan~', 
                    value: 'üî∏ **Xem file:** Click n√∫t xanh b√™n d∆∞·ªõi!\nüî∏ **Chia s·∫ª ngay:** Click n√∫t chia s·∫ª!\nüî∏ **Qu·∫£n l√Ω file:** Click n√∫t File Manager!',
                    inline: false 
                }
            ])
            .setFooter({ text: 'ÔøΩ Hina Bot ‚Ä¢ Em y√™u c·ªßa onii-chan' })
            .setTimestamp();

        const actionButtons = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setLabel('üåê Xem trong Drive')
                    .setStyle(ButtonStyle.Link)
                    .setURL(uploadedFile.webViewLink),
                new ButtonBuilder()
                    .setCustomId(`quick_share_${userId}_${uploadedFile.id}`)
                    .setLabel('üîó Chia s·∫ª ngay')
                    .setStyle(ButtonStyle.Success),
                new ButtonBuilder()
                    .setCustomId(`gdrive_list_${userId}`)
                    .setLabel('üìÅ File Manager')
                    .setStyle(ButtonStyle.Primary)
            );

        await interaction.editReply({ 
            embeds: [successEmbed], 
            components: [actionButtons] 
        });
        
        logger.info(`Upload successful for user ${userId}, file: ${uploadedFile.name}`);
        
    } catch (error) {
        logger.error(`Upload failed for user ${userId}:`, error.message);
        
        const errorEmbed = new EmbedBuilder()
            .setColor(EMBED_COLORS.ERROR)
            .setTitle('‚ùå Huhu~ Upload th·∫•t b·∫°i r·ªìi!')
            .setDescription(`Em kh√¥ng th·ªÉ upload file **${attachment.name}** ƒë∆∞·ª£c... üò¢`)
            .addFields([
                { 
                    name: '‚ö†Ô∏è Chi ti·∫øt l·ªói n√®~', 
                    value: error.message,
                    inline: false 
                },
                { 
                    name: 'üîß Gi·∫£i ph√°p cho onii-chan', 
                    value: '‚Ä¢ Ki·ªÉm tra k·∫øt n·ªëi m·∫°ng\n‚Ä¢ Th·ª≠ upload file kh√°c\n‚Ä¢ Ki·ªÉm tra quy·ªÅn truy c·∫≠p Google Drive\n‚Ä¢ Th·ª≠ l·∫°i sau v√†i ph√∫t nha! üíï',
                    inline: false 
                }
            ])
            .setFooter({ text: 'üíñ Hina Bot ‚Ä¢ Em xin l·ªói onii-chan...' })
            .setTimestamp();

        const retryActions = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId(`upload_retry_${userId}`)
                    .setLabel('üîÑ Th·ª≠ l·∫°i')
                    .setStyle(ButtonStyle.Primary),
                new ButtonBuilder()
                    .setCustomId(`gdrive_status_${userId}`)
                    .setLabel('ÔøΩ Ki·ªÉm tra k·∫øt n·ªëi')
                    .setStyle(ButtonStyle.Secondary)
            );

        await interaction.editReply({ 
            embeds: [errorEmbed], 
            components: [retryActions] 
        });
    }
}

async function handleDownload(interaction, userId, filenameParam = null) {
    if (!googleDriveService.isUserAuthenticated(userId)) {
        const embed = createNotConnectedEmbed();
        return await interaction.reply({ embeds: [embed], flags: MessageFlags.Ephemeral });
    }

    const filename = filenameParam || interaction.options.getString('filename');
    
    await interaction.deferReply({ flags: MessageFlags.Ephemeral });

    try {
        const loadingEmbed = createLoadingEmbed(
            'Searching File',
            `ƒêang t√¨m file **${filename}**... Ch·ªù em ch√∫t! üîç`
        );

        await interaction.editReply({ embeds: [loadingEmbed] });

        // Search for file by name
        const { files } = await googleDriveService.listFiles(userId);
        const file = files.find(f => f.name.toLowerCase().includes(filename.toLowerCase()));

        if (!file) {
            const notFoundEmbed = new EmbedBuilder()
                .setColor(EMBED_COLORS.ERROR)
                .setTitle('‚ùå Kh√¥ng t√¨m th·∫•y file n√®~')
                .setDescription(`Em kh√¥ng th·ªÉ t√¨m th·∫•y file **${filename}** trong Drive c·ªßa onii-chan! üòÖ`)
                .addFields([
                    { 
                        name: 'üîç G·ª£i √Ω t√¨m ki·∫øm~', 
                        value: '‚Ä¢ Ki·ªÉm tra t√™n file c√≥ ch√≠nh x√°c kh√¥ng\n‚Ä¢ Th·ª≠ t√¨m v·ªõi t·ª´ kh√≥a ng·∫Øn h∆°n\n‚Ä¢ S·ª≠ d·ª•ng File Manager ƒë·ªÉ duy·ªát file',
                        inline: false 
                    },
                    { 
                        name: 'üìã Xem t·∫•t c·∫£ file n√®~', 
                        value: 'Click n√∫t "üìÅ File Manager" ƒë·ªÉ xem danh s√°ch ƒë·∫ßy ƒë·ªß!',
                        inline: false 
                    }
                ])
                .setFooter({ text: 'üíñ Hina Bot ‚Ä¢ Em y√™u c·ªßa onii-chan' })
                .setTimestamp();

            const actionButtons = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId(`gdrive_list_${userId}`)
                        .setLabel('üìÅ File Manager')
                        .setStyle(ButtonStyle.Primary),
                    new ButtonBuilder()
                        .setCustomId(`gdrive_search_${userId}`)
                        .setLabel('üîç T√¨m ki·∫øm n√¢ng cao')
                        .setStyle(ButtonStyle.Secondary)
                );

            return await interaction.editReply({ 
                embeds: [notFoundEmbed], 
                components: [actionButtons] 
            });
        }

        // Create download info embed
        const fileInfoEmbed = new EmbedBuilder()
            .setColor(EMBED_COLORS.INFO)
            .setTitle('üì• T√¨m th·∫•y file r·ªìi!')
            .setDescription(`Kyaa~! Em ƒë√£ t√¨m th·∫•y file **${file.name}** cho onii-chan r·ªìi! üéâ`)
            .addFields([
                { 
                    name: 'üìÑ Th√¥ng tin file n√®~', 
                    value: `**${getEnhancedFileIcon(file.name)} T√™n:** ${file.name}\n` +
                          `**üìè K√≠ch th∆∞·ªõc:** ${formatFileSize(file.size || 0)}\n` +
                          `**üîñ Lo·∫°i:** ${file.mimeType}\n` +
                          `**üìÖ S·ª≠a ƒë·ªïi:** ${formatDate(file.modifiedTime)}`,
                    inline: false 
                },
                { 
                    name: 'üí° L∆∞u √Ω t·ª´ em~', 
                    value: '*Download qua Discord b·ªã gi·ªõi h·∫°n dung l∆∞·ª£ng. V·ªõi file l·ªõn, h√£y d√πng link Drive ƒë·ªÉ download nh√©! üíñ*',
                    inline: false 
                }
            ])
            .setFooter({ text: 'üíñ Hina Bot ‚Ä¢ Em y√™u c·ªßa onii-chan' })
            .setTimestamp();

        const downloadButtons = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId(`download_direct_${userId}_${file.id}`)
                    .setLabel('üì• Download Info')
                    .setStyle(ButtonStyle.Primary),
                new ButtonBuilder()
                    .setCustomId(`share_quick_${userId}_${file.id}`)
                    .setLabel('üîó Get Share Link')
                    .setStyle(ButtonStyle.Success),
                new ButtonBuilder()
                    .setLabel('üåê M·ªü trong Drive')
                    .setStyle(ButtonStyle.Link)
                    .setURL(file.webViewLink)
            );

        await interaction.editReply({
            embeds: [fileInfoEmbed],
            components: [downloadButtons]
        });
        
        logger.info(`Download interface sent successfully for user ${userId}, file: ${filename}`);
        
    } catch (error) {
        logger.error(`Download failed for user ${userId}:`, error.message);
        
        const errorEmbed = new EmbedBuilder()
            .setColor(EMBED_COLORS.ERROR)
            .setTitle('‚ùå L·ªói t√¨m file')
            .setDescription(`Em kh√¥ng th·ªÉ t√¨m file ƒë∆∞·ª£c... üò¢`)
            .addFields([
                { 
                    name: '‚ö†Ô∏è Chi ti·∫øt l·ªói', 
                    value: error.message,
                    inline: false 
                }
            ])
            .setFooter({ text: 'ÔøΩ Hina Bot ‚Ä¢ Error Handler' })
            .setTimestamp();

        const retryButton = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId(`download_retry_${userId}_${filename}`)
                    .setLabel('üîÑ Th·ª≠ l·∫°i')
                    .setStyle(ButtonStyle.Primary)
            );

        await interaction.editReply({ 
            embeds: [errorEmbed], 
            components: [retryButton] 
        });
    }
}

async function handleList(interaction, userId, folderId = null) {
    if (!googleDriveService.isUserAuthenticated(userId)) {
        const embed = createNotConnectedEmbed();
        return await interaction.reply({ embeds: [embed], flags: MessageFlags.Ephemeral });
    }

    const folderName = interaction.options?.getString('folder');
    
    await interaction.deferReply({ flags: MessageFlags.Ephemeral });

    try {
        const loadingEmbed = createLoadingEmbed(
            'Loading Files',
            'ƒêang t·∫£i danh s√°ch file... Ch·ªù ch√∫t! üìÇ'
        );

        await interaction.editReply({ embeds: [loadingEmbed] });

        // Get folder contents with navigation support
        const { folders, files } = await googleDriveService.listFiles(userId, folderId);
        
        const embed = new EmbedBuilder()
            .setColor(EMBED_COLORS.INFO)
            .setTitle('üìÅ File Manager - Em s·∫Ω gi√∫p onii-chan qu·∫£n l√Ω file n√®~')
            .setDescription(`üè† **ƒêang xem:** ${folderName || 'Home'}\nüìä **T·ªïng c·ªông:** ${folders.length + files.length} items`)
            .setTimestamp();

        // Display folders section
        if (folders.length > 0) {
            const folderList = folders.slice(0, MAX_FOLDER_DISPLAY).map(folder => 
                `${getFolderIcon()} **${truncateString(folder.name, 25)}**\n` +
                `üìÖ ${formatDate(folder.modifiedTime)}`
            ).join('\n\n');
            
            embed.addFields({
                name: `üìÅ Folders (${folders.length})`,
                value: folderList + (folders.length > MAX_FOLDER_DISPLAY ? `\n\n*...v√† ${folders.length - MAX_FOLDER_DISPLAY} folders kh√°c*` : ''),
                inline: false
            });
        }

        // Display files section  
        if (files.length > 0) {
            const fileList = files.slice(0, MAX_FILE_DISPLAY).map(file => 
                `${getEnhancedFileIcon(file.name)} **${truncateString(file.name, 25)}**\n` +
                `üìè ${formatFileSize(file.size || 0)} ‚Ä¢ üìÖ ${formatDate(file.modifiedTime)}`
            ).join('\n\n');
            
            embed.addFields({
                name: `üìÑ Files (${files.length})`,
                value: fileList + (files.length > MAX_FILE_DISPLAY ? `\n\n*...v√† ${files.length - MAX_FILE_DISPLAY} files kh√°c*` : ''),
                inline: false
            });
        }

        // Show empty message if no content
        if (folders.length === 0 && files.length === 0) {
            embed.setDescription('üì≠ Drive c·ªßa onii-chan tr·ªëng! H√£y upload file ƒë·∫ßu ti√™n nh√©! ‚ú®');
        }

        // Create action components
        const components = [];
        
        // Navigation buttons (first row)
        const navButtons = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId(`gdrive_refresh_${userId}`)
                    .setLabel('üîÑ L√†m m·ªõi')
                    .setStyle(ButtonStyle.Primary),
                new ButtonBuilder()
                    .setCustomId(`gdrive_upload_${userId}`)
                    .setLabel('üì§ Upload')
                    .setStyle(ButtonStyle.Success),
                new ButtonBuilder()
                    .setCustomId(`gdrive_search_${userId}`)
                    .setLabel('ÔøΩ T√¨m ki·∫øm')
                    .setStyle(ButtonStyle.Secondary)
            );
        
        components.push(navButtons);

        // Quick action buttons for files (if any)
        if (files.length > 0) {
            const quickActions = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId(`gdrive_quickshare_${userId}`)
                        .setLabel('üîó Chia s·∫ª nhanh')
                        .setStyle(ButtonStyle.Primary),
                    new ButtonBuilder()
                        .setCustomId(`gdrive_quickdownload_${userId}`)
                        .setLabel('ÔøΩ T·∫£i xu·ªëng')
                        .setStyle(ButtonStyle.Success)
                );
            components.push(quickActions);
        }
        
        embed.setFooter({ 
            text: `üíñ Hina Bot ‚Ä¢ Em y√™u c·ªßa onii-chan ‚Ä¢ ${new Date().toLocaleTimeString('vi-VN')} ‚Ä¢ Click buttons ƒë·ªÉ thao t√°c n√®~` 
        });
        
        await interaction.editReply({ 
            embeds: [embed], 
            components: components 
        });
        
    } catch (error) {
        logger.error(`List files failed for user ${userId}:`, error.message);
        
        const errorEmbed = new EmbedBuilder()
            .setColor(EMBED_COLORS.ERROR)
            .setTitle('‚ùå L·ªói File Manager')
            .setDescription('Kh√¥ng th·ªÉ t·∫£i File Manager. Vui l√≤ng th·ª≠ l·∫°i.')
            .addFields([
                { 
                    name: '‚ö†Ô∏è Chi ti·∫øt l·ªói', 
                    value: error.message,
                    inline: false 
                },
                { 
                    name: 'üîß Gi·∫£i ph√°p', 
                    value: '‚Ä¢ Ki·ªÉm tra k·∫øt n·ªëi Google Drive\n‚Ä¢ Th·ª≠ l·∫°i sau v√†i gi√¢y\n‚Ä¢ Li√™n h·ªá h·ªó tr·ª£ n·∫øu v·∫•n ƒë·ªÅ ti·∫øp t·ª•c',
                    inline: false 
                }
            ])
            .setFooter({ text: 'üíñ Hina Bot ‚Ä¢ Error Handler' })
            .setTimestamp();
        
        const retryButton = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId(`gdrive_refresh_${userId}`)
                    .setLabel('ÔøΩ Th·ª≠ l·∫°i')
                    .setStyle(ButtonStyle.Primary)
            );
        
        await interaction.editReply({ 
            embeds: [errorEmbed], 
            components: [retryButton] 
        });
    }
}

async function handleShare(interaction, userId) {
    if (!googleDriveService.isUserAuthenticated(userId)) {
        const embed = createNotConnectedEmbed();
        return await interaction.reply({ embeds: [embed], flags: MessageFlags.Ephemeral });
    }

    const filename = interaction.options.getString('filename');
    
    await interaction.deferReply({ flags: MessageFlags.Ephemeral });

    try {
        const loadingEmbed = createLoadingEmbed(
            'Sharing File',
            `ƒêang t√¨m v√† chia s·∫ª file **${filename}**... Ch·ªù ch√∫t! üîó`
        );

        await interaction.editReply({ embeds: [loadingEmbed] });

        // Search for file by name
        const { files } = await googleDriveService.listFiles(userId);
        const file = files.find(f => f.name.toLowerCase().includes(filename.toLowerCase()));

        if (!file) {
            const notFoundEmbed = createErrorEmbed(
                'File Not Found',
                `Kh√¥ng t√¨m th·∫•y file **${filename}** üòÖ\nH√£y ki·ªÉm tra t√™n file v√† th·ª≠ l·∫°i nh√©!`
            );

            return await interaction.editReply({ embeds: [notFoundEmbed] });
        }

        const sharedFile = await googleDriveService.shareFile(userId, file.id);
        
        // Create stunning visual share embed
        const shareEmbed = new EmbedBuilder()
            .setColor(EMBED_COLORS.SHARE)
            .setTitle('üåü Kyaa~! File ƒë√£ ƒë∆∞·ª£c chia s·∫ª th√†nh c√¥ng r·ªìi!')
            .setDescription(`‚ú® **${filename}** gi·ªù m·ªçi ng∆∞·ªùi c√≥ link ƒë·ªÅu c√≥ th·ªÉ xem ƒë∆∞·ª£c ƒë·∫•y! üéâ\n\n` +
                          `üéØ **Tr·∫°ng th√°i:** üü¢ C√¥ng khai n√®~\n` +
                          `üîë **Quy·ªÅn h·∫°n:** üìñ Ch·ªâ ƒë·ªçc th√¥i nh√©\n` +
                          `‚ö° **Chia s·∫ª:** üë• Ai c√≥ link c≈©ng xem ƒë∆∞·ª£c!`)
            .addFields([
                { 
                    name: 'üìã Th√¥ng tin chi ti·∫øt n√®~', 
                    value: `**${getEnhancedFileIcon(filename)} T√™n file:** \`${filename}\`\n` +
                          `**üÜî File ID:** \`${file.id}\`\n` +
                          `**üìÖ Chia s·∫ª l√∫c:** <t:${Math.floor(Date.now() / 1000)}:R>\n` +
                          `**üîê B·∫£o m·∫≠t:** Ch·ªâ ng∆∞·ªùi c√≥ link m·ªõi xem ƒë∆∞·ª£c nh√©! üîí`,
                    inline: false 
                },
                { 
                    name: 'üöÄ H√†nh ƒë·ªông nhanh cho onii-chan~', 
                    value: `üî∏ **Copy link xem:** Click n√∫t xanh d∆∞·ªõi ƒë√¢y!\n` +
                          `üî∏ **Copy link t·∫£i:** Click n√∫t xanh l√° cute!\n` +
                          `üî∏ **M·ªü Drive:** Click n√∫t x√°m nh√©~\n` +
                          `üî∏ **Xem chi ti·∫øt:** Click n√∫t th√¥ng tin!`,
                    inline: false 
                }
            ])
            .setFooter({ 
                text: 'üíñ Hina Bot ‚Ä¢ Em y√™u c·ªßa onii-chan ‚Ä¢ Click buttons ƒë·ªÉ thao t√°c nhanh n√®~!'
            })
            .setTimestamp();
        
        // Enhanced action buttons with better visuals
        const primaryActions = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setLabel('üîó View File')
                    .setStyle(ButtonStyle.Link)
                    .setURL(sharedFile.webViewLink),
                new ButtonBuilder()
                    .setLabel('‚¨áÔ∏è Download')
                    .setStyle(ButtonStyle.Link)
                    .setURL(sharedFile.webContentLink || sharedFile.webViewLink),
                new ButtonBuilder()
                    .setCustomId(`share_info_${userId}_${file.id}`)
                    .setLabel('üìä Chi Ti·∫øt')
                    .setStyle(ButtonStyle.Secondary)
            );
        
        await interaction.editReply({
            embeds: [shareEmbed],
            components: [primaryActions]
        });
        
        logger.info(`Share interface sent successfully for user ${userId}, file: ${filename}`);
        
    } catch (error) {
        logger.error(`Share failed for user ${userId}:`, error.message);
        
        const errorEmbed = new EmbedBuilder()
            .setColor(EMBED_COLORS.ERROR)
            .setTitle('‚ùå Huhu~ L·ªói chia s·∫ª file r·ªìi!')
            .setDescription(`Em kh√¥ng th·ªÉ chia s·∫ª file **${filename}** ƒë∆∞·ª£c... üò¢`)
            .addFields([
                { 
                    name: '‚ö†Ô∏è Chi ti·∫øt l·ªói n√®~', 
                    value: error.message,
                    inline: false 
                },
                { 
                    name: 'üîß Gi·∫£i ph√°p cho onii-chan', 
                    value: '‚Ä¢ Ki·ªÉm tra t√™n file c√≥ ch√≠nh x√°c kh√¥ng nh√©~\n‚Ä¢ ƒê·∫£m b·∫£o file t·ªìn t·∫°i trong Drive\n‚Ä¢ Th·ª≠ l·∫°i sau v√†i ph√∫t nha! üíï',
                    inline: false 
                }
            ])
            .setFooter({ text: 'üíñ Hina Bot ‚Ä¢ Em xin l·ªói onii-chan...' })
            .setTimestamp();
        
        const retryActions = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId(`share_retry_${userId}_${filename}`)
                    .setLabel('üîÑ Th·ª≠ l·∫°i')
                    .setStyle(ButtonStyle.Primary),
                new ButtonBuilder()
                    .setCustomId(`gdrive_list_${userId}`)
                    .setLabel('ÔøΩ Xem danh s√°ch')
                    .setStyle(ButtonStyle.Secondary)
            );
        
        await interaction.editReply({ 
            embeds: [errorEmbed], 
            components: [retryActions] 
        });
    }
}

async function handleDelete(interaction, userId) {
    if (!googleDriveService.isUserAuthenticated(userId)) {
        const embed = createNotConnectedEmbed();
        return await interaction.reply({ embeds: [embed], flags: MessageFlags.Ephemeral });
    }

    const filename = interaction.options.getString('filename');
    
    await interaction.deferReply({ flags: MessageFlags.Ephemeral });

    try {
        const loadingEmbed = createLoadingEmbed(
            'Searching File',
            `ƒêang t√¨m file **${filename}**... Ch·ªù ch√∫t! üîç`
        );

        await interaction.editReply({ embeds: [loadingEmbed] });

        // Search for file by name
        const { files } = await googleDriveService.listFiles(userId);
        const file = files.find(f => f.name.toLowerCase().includes(filename.toLowerCase()));

        if (!file) {
            const notFoundEmbed = new EmbedBuilder()
                .setColor(EMBED_COLORS.ERROR)
                .setTitle('‚ùå Kh√¥ng t√¨m th·∫•y file n√®~')
                .setDescription(`Em kh√¥ng th·ªÉ t√¨m th·∫•y file **${filename}** ƒë·ªÉ x√≥a! üòÖ`)
                .addFields([
                    { 
                        name: 'üîç Ki·ªÉm tra l·∫°i n√®~', 
                        value: '‚Ä¢ T√™n file c√≥ ch√≠nh x√°c kh√¥ng?\n‚Ä¢ File c√≥ t·ªìn t·∫°i trong Drive kh√¥ng?\n‚Ä¢ Th·ª≠ t√¨m v·ªõi t·ª´ kh√≥a kh√°c',
                        inline: false 
                    }
                ])
                .setFooter({ text: 'üíñ Hina Bot ‚Ä¢ Em y√™u c·ªßa onii-chan' })
                .setTimestamp();

            const actionButtons = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId(`gdrive_list_${userId}`)
                        .setLabel('üìã Xem danh s√°ch')
                        .setStyle(ButtonStyle.Secondary)
                );

            return await interaction.editReply({ 
                embeds: [notFoundEmbed], 
                components: [actionButtons] 
            });
        }

        // Show confirmation with enhanced styling
        const confirmEmbed = new EmbedBuilder()
            .setColor(EMBED_COLORS.WARNING)
            .setTitle('‚ö†Ô∏è X√°c nh·∫≠n x√≥a file')
            .setDescription(`Onii-chan c√≥ ch·∫Øc ch·∫Øn mu·ªën x√≥a file n√†y kh√¥ng? ü•∫`)
            .addFields([
                { 
                    name: 'üìÑ File s·∫Ω b·ªã x√≥a~', 
                    value: `**${getEnhancedFileIcon(file.name)} T√™n:** ${file.name}\n` +
                          `**üìè K√≠ch th∆∞·ªõc:** ${formatFileSize(file.size || 0)}\n` +
                          `**üìÖ S·ª≠a ƒë·ªïi:** ${formatDate(file.modifiedTime)}`,
                    inline: false 
                },
                { 
                    name: 'üö® C·∫£nh b√°o quan tr·ªçng!', 
                    value: '**H√†nh ƒë·ªông n√†y kh√¥ng th·ªÉ ho√†n t√°c!**\nFile s·∫Ω b·ªã x√≥a vƒ©nh vi·ªÖn kh·ªèi Google Drive! üíÄ',
                    inline: false 
                }
            ])
            .setFooter({ text: 'üíñ Hina Bot ‚Ä¢ Em y√™u c·ªßa onii-chan ‚Ä¢ H√£y suy nghƒ© k·ªπ nh√©!' })
            .setTimestamp();

        const confirmButtons = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId(`confirm_delete_${userId}_${file.id}`)
                    .setLabel('üóëÔ∏è X√°c nh·∫≠n x√≥a')
                    .setStyle(ButtonStyle.Danger),
                new ButtonBuilder()
                    .setCustomId(`cancel_delete_${userId}`)
                    .setLabel('‚ùå H·ªßy b·ªè')
                    .setStyle(ButtonStyle.Secondary),
                new ButtonBuilder()
                    .setLabel('üåê Xem file tr∆∞·ªõc')
                    .setStyle(ButtonStyle.Link)
                    .setURL(file.webViewLink)
            );

        await interaction.editReply({
            embeds: [confirmEmbed],
            components: [confirmButtons]
        });
        
        logger.info(`Delete confirmation sent for user ${userId}, file: ${filename}`);
        
    } catch (error) {
        logger.error(`Delete operation failed for user ${userId}:`, error.message);
        
        const errorEmbed = new EmbedBuilder()
            .setColor(EMBED_COLORS.ERROR)
            .setTitle('‚ùå L·ªói t√¨m file ƒë·ªÉ x√≥a')
            .setDescription(`Em kh√¥ng th·ªÉ t√¨m file ƒë·ªÉ x√≥a... üò¢`)
            .addFields([
                { 
                    name: '‚ö†Ô∏è Chi ti·∫øt l·ªói', 
                    value: error.message,
                    inline: false 
                }
            ])
            .setFooter({ text: 'üíñ Hina Bot ‚Ä¢ Error Handler' })
            .setTimestamp();

        const retryButton = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId(`delete_retry_${userId}_${filename}`)
                    .setLabel('üîÑ Th·ª≠ l·∫°i')
                    .setStyle(ButtonStyle.Primary)
            );

        await interaction.editReply({ 
            embeds: [errorEmbed], 
            components: [retryButton] 
        });
    }
}

// Button handler functions for enhanced interactions

/**
 * Handle share view button
 */
export async function handleShareView(interaction, userId, fileId) {
    try {
        if (!googleDriveService.isUserAuthenticated(userId)) {
            const embed = createNotConnectedEmbed();
            return await interaction.reply({ embeds: [embed], flags: MessageFlags.Ephemeral });
        }

        const fileInfo = await googleDriveService.getFileInfo(userId, fileId);
        
        await interaction.reply({
            content: `üîó **View Link:** ${fileInfo.webViewLink}\n\n*Copy link n√†y ƒë·ªÉ xem file nh√©! üíñ*`,
            flags: MessageFlags.Ephemeral
        });
    } catch (error) {
        logger.error(`Share view failed:`, error);
        await interaction.reply({
            content: `‚ùå Kh√¥ng th·ªÉ l·∫•y link xem: ${error.message}`,
            flags: MessageFlags.Ephemeral
        });
    }
}

/**
 * Handle share download button
 */
export async function handleShareDownload(interaction, userId, fileId) {
    try {
        if (!googleDriveService.isUserAuthenticated(userId)) {
            const embed = createNotConnectedEmbed();
            return await interaction.reply({ embeds: [embed], flags: MessageFlags.Ephemeral });
        }

        const fileInfo = await googleDriveService.getFileInfo(userId, fileId);
        
        await interaction.reply({
            content: `üì• **Download Link:** ${fileInfo.webContentLink || fileInfo.webViewLink}\n\n*Copy link n√†y ƒë·ªÉ download file nh√©! üíñ*`,
            flags: MessageFlags.Ephemeral
        });
    } catch (error) {
        logger.error(`Share download failed:`, error);
        await interaction.reply({
            content: `‚ùå Kh√¥ng th·ªÉ l·∫•y link download: ${error.message}`,
            flags: MessageFlags.Ephemeral
        });
    }
}

/**
 * Handle quick share button
 */
export async function handleQuickShare(interaction, userId, fileId) {
    try {
        await interaction.deferReply({ flags: MessageFlags.Ephemeral });
        
        const sharedFile = await googleDriveService.shareFile(userId, fileId);
        
        const embed = new EmbedBuilder()
            .setColor(EMBED_COLORS.SUCCESS)
            .setTitle('üîó File ƒë√£ ƒë∆∞·ª£c chia s·∫ª!')
            .setDescription(`File ƒë∆∞·ª£c chia s·∫ª th√†nh c√¥ng! ${getRandomCuteResponse()}`)
            .addFields([
                {
                    name: 'üåê Links',
                    value: `**View:** [Click here](${sharedFile.webViewLink})\n**Download:** [Click here](${sharedFile.webContentLink || sharedFile.webViewLink})`,
                    inline: false
                }
            ])
            .setTimestamp();

        await interaction.editReply({ embeds: [embed] });
    } catch (error) {
        logger.error(`Quick share failed:`, error);
        const errorEmbed = createErrorEmbed('Share Failed', `Kh√¥ng th·ªÉ chia s·∫ª file: ${error.message}`);
        await interaction.editReply({ embeds: [errorEmbed] });
    }
}

/**
 * Handle confirm delete button
 */
export async function handleConfirmDelete(interaction, userId, fileId) {
    try {
        await interaction.deferReply({ flags: MessageFlags.Ephemeral });
        
        await googleDriveService.deleteFile(userId, fileId);
        
        const successEmbed = new EmbedBuilder()
            .setColor(EMBED_COLORS.SUCCESS)
            .setTitle('üóëÔ∏è File ƒë√£ ƒë∆∞·ª£c x√≥a!')
            .setDescription(`File ƒë√£ ƒë∆∞·ª£c x√≥a th√†nh c√¥ng kh·ªèi Google Drive! ${getRandomCuteResponse()}`)
            .setTimestamp();

        await interaction.editReply({ embeds: [successEmbed] });
    } catch (error) {
        logger.error(`Delete failed:`, error);
        const errorEmbed = createErrorEmbed('Delete Failed', `Kh√¥ng th·ªÉ x√≥a file: ${error.message}`);
        await interaction.editReply({ embeds: [errorEmbed] });
    }
}

/**
 * Handle cancel delete button
 */
export async function handleCancelDelete(interaction, userId) {
    const embed = createInfoEmbed(
        'Delete Cancelled',
        'ƒê√£ h·ªßy vi·ªác x√≥a file! File c·ªßa onii-chan v·∫´n an to√†n~ üíñ'
    );
    
    await interaction.reply({ embeds: [embed], flags: MessageFlags.Ephemeral });
}

/**
 * Handle list refresh button
 */
export async function handleListRefresh(interaction, userId) {
    await handleList(interaction, userId);
}
